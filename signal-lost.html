<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, interactive-widget=resizes-content">
<title>SIGNAL LOST</title>
<style>
@import url('https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@400;500;700&display=swap');

*{margin:0;padding:0;box-sizing:border-box}

:root{
  --glow:#d4d4d4;
  --dim:#999;
  --bg:#0a0a0a;
  --panel:#111;
  --border:#333;
  --highlight:#fff;
  --danger:#888;
}

html,body{
  height:100%;
  background:#000;
  color:var(--glow);
  font-family:'IBM Plex Mono',monospace;
  font-size:13px;
  overflow:hidden;
}

/* CRT Effect Container */
#crt{
  position:relative;
  width:100%;
  height:100%;
  overflow:hidden;
}

/* Scanlines */
#crt::before{
  content:'';
  position:absolute;
  top:0;left:0;right:0;bottom:0;
  background:repeating-linear-gradient(
    0deg,
    transparent,
    transparent 2px,
    rgba(0,0,0,0.15) 2px,
    rgba(0,0,0,0.15) 4px
  );
  pointer-events:none;
  z-index:100;
}

/* Vignette */
#crt::after{
  content:'';
  position:absolute;
  top:0;left:0;right:0;bottom:0;
  background:radial-gradient(ellipse at center, transparent 60%, rgba(0,0,0,0.6) 100%);
  pointer-events:none;
  z-index:101;
}

/* Screen flicker */
@keyframes flicker{
  0%{opacity:1}
  3%{opacity:0.97}
  6%{opacity:1}
  50%{opacity:1}
  53%{opacity:0.98}
  56%{opacity:1}
}
#crt{animation:flicker 4s infinite}

/* Layout */
#game{
  display:grid;
  grid-template-rows:auto 1fr auto;
  height:100%;
  padding:8px;
  gap:4px;
}

/* Header */
#header{
  display:flex;
  justify-content:space-between;
  align-items:center;
  padding:6px 12px;
  border:1px solid var(--border);
  background:var(--panel);
}
#header h1{font-size:14px;letter-spacing:4px;font-weight:700;text-transform:uppercase}
#header .time{font-size:13px;color:var(--dim)}

/* Main area */
#main{
  display:grid;
  grid-template-columns:1fr 1fr;
  gap:4px;
  overflow:hidden;
  min-height:0;
}

/* Panels */
.panel{
  border:1px solid var(--border);
  background:var(--panel);
  display:flex;
  flex-direction:column;
  overflow:hidden;
  min-height:0;
}
.panel-title{
  padding:4px 10px;
  border-bottom:1px solid var(--border);
  font-size:11px;
  letter-spacing:2px;
  font-weight:700;
  text-transform:uppercase;
  color:var(--dim);
  flex-shrink:0;
}

/* Map */
#map-container{
  flex:1;
  overflow:hidden;
  display:flex;
  align-items:center;
  justify-content:center;
  padding:8px;
}
#map{
  font-size:14px;
  line-height:1.6;
  letter-spacing:2px;
  white-space:pre;
}
.map-enemy{color:var(--glow);font-weight:bold}
.map-friendly{color:var(--highlight);font-weight:bold}
.map-poi{color:var(--dim)}

/* Right column */
#right-col{
  display:grid;
  grid-template-rows:1fr auto;
  gap:4px;
  min-height:0;
}

/* Radio Log */
#radio-log-container{
  flex:1;
  overflow-y:auto;
  padding:8px 10px;
  scroll-behavior:smooth;
}
#radio-log-container::-webkit-scrollbar{width:4px}
#radio-log-container::-webkit-scrollbar-track{background:var(--bg)}
#radio-log-container::-webkit-scrollbar-thumb{background:var(--border)}

.radio-msg{
  margin-bottom:6px;
  line-height:1.5;
  animation:fadeIn 0.3s ease;
}
@keyframes fadeIn{from{opacity:0;transform:translateY(4px)}to{opacity:1;transform:translateY(0)}}

.radio-msg .timestamp{color:var(--dim);font-size:11px}
.radio-msg .callsign{font-weight:700;color:var(--highlight)}
.radio-msg .callsign.command{color:var(--glow)}
.radio-msg .callsign.system{color:var(--dim)}
.radio-msg.garbled .body{
  color:var(--dim);
  font-style:italic;
}
.radio-msg.urgent{
  border-left:2px solid var(--highlight);
  padding-left:8px;
}
.radio-msg.event{
  border-left:2px solid var(--dim);
  padding-left:8px;
  color:var(--dim);
}

/* Squad Status */
#squad-status{
  padding:8px 10px;
}
.squad-row{
  display:flex;
  align-items:center;
  gap:10px;
  margin-bottom:4px;
  font-size:12px;
}
.squad-row .name{width:60px;font-weight:700;flex-shrink:0}
.stat{display:flex;gap:2px;align-items:center}
.stat-label{font-size:10px;color:var(--dim);width:24px}
.stat-bar{display:flex;gap:1px}
.stat-pip{
  width:8px;height:8px;
  border:1px solid var(--border);
  background:transparent;
}
.stat-pip.filled{background:var(--glow);border-color:var(--glow)}
.stat-pip.critical{background:var(--glow);border-color:var(--glow);animation:blink 1s infinite}
@keyframes blink{0%,100%{opacity:1}50%{opacity:0.3}}

.squad-extra{font-size:10px;color:var(--dim);margin-left:auto}

/* Command Input */
#input-area{
  display:flex;
  border:1px solid var(--border);
  background:var(--panel);
  align-items:center;
}
#input-area label{
  padding:6px 10px;
  font-weight:700;
  color:var(--dim);
  font-size:12px;
  flex-shrink:0;
}
#cmd{
  flex:1;
  background:transparent;
  border:none;
  color:var(--highlight);
  font-family:inherit;
  font-size:13px;
  padding:8px 4px;
  outline:none;
  caret-color:var(--highlight);
}
#cmd::placeholder{color:#767676}

/* Briefing Overlay */
#briefing-overlay{
  position:fixed;
  top:0;left:0;right:0;bottom:0;
  background:rgba(0,0,0,0.95);
  z-index:200;
  display:flex;
  align-items:center;
  justify-content:center;
}
#briefing-overlay.hidden{display:none}
#briefing{
  max-width:640px;
  padding:40px;
  border:1px solid var(--border);
  background:var(--panel);
}
#briefing h2{
  font-size:16px;
  letter-spacing:4px;
  margin-bottom:20px;
  text-transform:uppercase;
}
#briefing p{
  line-height:1.8;
  margin-bottom:12px;
  color:var(--glow);
}
#briefing .objectives{
  border:1px solid var(--border);
  padding:12px;
  margin:16px 0;
}
#briefing .objectives h3{
  font-size:11px;
  letter-spacing:2px;
  color:var(--dim);
  margin-bottom:8px;
  text-transform:uppercase;
}
#briefing .objectives li{
  list-style:none;
  padding:2px 0;
  line-height:1.6;
}
#briefing .objectives li::before{content:'▸ '}
#briefing button{
  background:transparent;
  border:1px solid var(--glow);
  color:var(--glow);
  padding:8px 24px;
  font-family:inherit;
  font-size:12px;
  letter-spacing:2px;
  text-transform:uppercase;
  cursor:pointer;
  margin-top:16px;
}
#briefing button:hover{background:var(--glow);color:var(--bg)}

/* Game Over Overlay */
#gameover-overlay{
  position:fixed;
  top:0;left:0;right:0;bottom:0;
  background:rgba(0,0,0,0.95);
  z-index:200;
  display:flex;
  align-items:center;
  justify-content:center;
}
#gameover-overlay.hidden{display:none}
#gameover{
  max-width:500px;
  padding:40px;
  border:1px solid var(--border);
  background:var(--panel);
  text-align:center;
}
#gameover h2{font-size:18px;letter-spacing:6px;margin-bottom:20px;text-transform:uppercase}
#gameover p{line-height:1.8;margin-bottom:8px;color:var(--glow)}
#gameover button{
  background:transparent;
  border:1px solid var(--glow);
  color:var(--glow);
  padding:8px 24px;
  font-family:inherit;
  font-size:12px;
  letter-spacing:2px;
  text-transform:uppercase;
  cursor:pointer;
  margin-top:20px;
}
#gameover button:hover{background:var(--glow);color:var(--bg)}

/* Choice overlay */
#choice-overlay{
  position:fixed;
  bottom:60px;
  left:50%;
  transform:translateX(-50%);
  z-index:150;
  background:var(--panel);
  border:1px solid var(--border);
  padding:12px 16px;
  max-width:600px;
  width:90%;
}
#choice-overlay.hidden{display:none}
#choice-prompt{margin-bottom:10px;font-size:12px;color:var(--glow)}
#choice-options{display:flex;gap:8px;flex-wrap:wrap}
#choice-options button{
  background:transparent;
  border:1px solid var(--border);
  color:var(--glow);
  padding:6px 16px;
  font-family:inherit;
  font-size:11px;
  letter-spacing:1px;
  cursor:pointer;
  text-transform:uppercase;
}
#choice-options button:hover{background:var(--glow);color:var(--bg)}
button:focus-visible { outline: 2px solid var(--highlight); outline-offset: 2px; }
#cmd:focus-visible { outline: 1px solid var(--glow); }
@media (prefers-reduced-motion: reduce) {
  #crt { animation: none; }
  #crt::before { display: none; }
  .radio-msg { animation: none; }
  .stat-pip.critical { animation: none; }
}
@media (max-width: 768px) {
  html, body { font-size: 14px; height: 100dvh; }
  #game { height: 100dvh; }
  #main { grid-template-columns: 1fr; grid-template-rows: auto 1fr; overflow-y: auto; -webkit-overflow-scrolling: touch; }
  #right-col { min-height: 200px; }
  #map-panel { max-height: 40vh; }
  .panel-title { font-size: 12px; padding: 6px 10px; }
  .squad-row { font-size: 13px; flex-wrap: wrap; }
  .stat-label { font-size: 11px; }
  .stat-pip { width: 10px; height: 10px; }
  #briefing button, #gameover button { padding: 14px 28px; }
  #choice-options button { padding: 12px 20px; }
  #cmd { padding: 12px 8px; font-size: 16px; }
  #input-area { position: sticky; bottom: 0; z-index: 50; }
  #briefing, #gameover { padding: 20px; max-width: calc(100vw - 32px); max-height: calc(100dvh - 32px); overflow-y: auto; }
  #choice-overlay { top: 50%; bottom: auto; transform: translate(-50%, -50%); }
  #radio-log-container::-webkit-scrollbar { width: 8px; }
  #crt::before { display: none; }
  #crt { animation: none; }
}
@media (max-width: 480px) {
  #header { flex-direction: column; align-items: flex-start; gap: 4px; }
  #map { font-size: 11px; letter-spacing: 1px; line-height: 1.4; }
  #map-container { overflow: auto; -webkit-overflow-scrolling: touch; justify-content: flex-start; }
}
@media (max-height: 500px) and (orientation: landscape) {
  #header { padding: 2px 8px; }
  #header h1 { font-size: 12px; }
  #main { grid-template-columns: 1fr 1fr; gap: 2px; }
  .panel-title { padding: 2px 8px; font-size: 10px; }
  #game { padding: 2px; gap: 2px; }
}
</style>
</head>
<body>
<div id="crt">
<div id="game" role="main">
  <div id="header">
    <h1>Signal Lost</h1>
    <div><span id="op-name">Operation Bright Light</span> &nbsp;│&nbsp; <span class="time" id="clock">06:00</span> &nbsp;│&nbsp; <button id="pause-play" onclick="togglePause()" aria-label="Pause game" style="cursor:pointer;font-size:12px;letter-spacing:1px;background:none;border:1px solid var(--border);font-family:inherit;color:var(--glow);padding:2px 8px">PAUSE</button> &nbsp;│&nbsp; <button id="tts-toggle" onclick="toggleTTS()" aria-pressed="true" style="cursor:pointer;font-size:12px;letter-spacing:1px;background:none;border:none;font-family:inherit;color:var(--dim)">VOICE: ON</button></div>
  </div>

  <div id="main">
    <div class="panel" id="map-panel" role="region" aria-label="Tactical Map">
      <h2 class="panel-title">Tactical Map</h2>
      <div id="map-container"><pre id="map" role="img"></pre></div>
    </div>
    <div id="right-col">
      <div class="panel" id="radio-panel" role="region" aria-label="Radio Log">
        <h2 class="panel-title">Radio Log</h2>
        <div id="radio-log-container" role="log" aria-live="polite" aria-relevant="additions"></div>
      </div>
      <div class="panel" id="status-panel" role="region" aria-label="Squad Status">
        <h2 class="panel-title">Squad Status</h2>
        <div id="squad-status" aria-live="polite" aria-atomic="false"></div>
      </div>
    </div>
  </div>

  <div id="input-area">
    <label for="cmd">▸ COMMAND:</label>
    <input type="text" id="cmd" placeholder="Type command... (HELP for commands)" autocomplete="off" spellcheck="false" autocapitalize="characters" inputmode="text" disabled>
  </div>
</div>
</div>

<div id="briefing-overlay">
  <div id="briefing" role="dialog" aria-modal="true" aria-labelledby="briefing-title">
    <h2 id="briefing-title">Operation Bright Light</h2>
    <p>Commander, we've lost contact with a recon patrol — callsign VIPER — last reported near grid sector E5. Local intel suggests enemy activity in the area has intensified over the past 48 hours.</p>
    <p>You have two infantry squads at your disposal. Locate the missing patrol and extract any survivors. A medevac helicopter — callsign DUSTOFF — is on standby at base.</p>
    <div class="objectives">
      <h3>Mission Objectives</h3>
      <ul role="list">
        <li>Locate missing recon patrol (VIPER)</li>
        <li>Extract at least 2 survivors via DUSTOFF</li>
        <li>Minimize casualties</li>
      </ul>
    </div>
    <p style="color:var(--dim);font-size:11px">Available assets: ALPHA squad (grid B2), BRAVO squad (grid B6), DUSTOFF medevac (base). Fire support available. Time limit: 20 minutes.</p>
    <div style="color:var(--dim);font-size:11px;margin-top:8px;border-top:1px solid var(--dim);padding-top:8px">
      <strong style="color:var(--highlight)">Quick start:</strong> Move squads with <code>ALPHA MOVE E5</code>. Use <code>AMBUSH</code> before entering hostile areas. Check the village at C3 for intel. Type <code>HELP</code> anytime.
    </div>
    <button onclick="startGame()">Begin Mission</button>
  </div>
</div>

<div id="gameover-overlay" class="hidden">
  <div id="gameover" role="dialog" aria-modal="true" aria-labelledby="gameover-title">
    <h2 id="gameover-title">MISSION COMPLETE</h2>
    <p id="gameover-text"></p>
    <p id="gameover-stats"></p>
    <button onclick="location.reload()">New Mission</button>
  </div>
</div>

<div id="choice-overlay" class="hidden">
  <div id="choice-prompt"></div>
  <div id="choice-options"></div>
</div>

<script>
// ─── TEXT-TO-SPEECH (RADIO VOICES) ────────────────────
const tts = {
  enabled: true,
  synth: window.speechSynthesis || null,
  queue: [],
  speaking: false,
  voices: null,

  // Voice profiles per callsign — pitch/rate tuned for character
  profiles: {
    ALPHA:     { pitch: 0.9,  rate: 1.05, volume: 0.9 },
    BRAVO:     { pitch: 1.15, rate: 1.15, volume: 0.85 },
    DUSTOFF:   { pitch: 0.8,  rate: 0.95, volume: 0.9 },
    COMMAND:   { pitch: 1.0,  rate: 0.95, volume: 1.0 },
    HQ:        { pitch: 0.75, rate: 0.9,  volume: 0.85 },
    ARTILLERY: { pitch: 0.7,  rate: 1.0,  volume: 0.9 },
    FALCON:    { pitch: 0.85, rate: 1.1,  volume: 0.9 },
    SYSTEM:    { pitch: 0.6,  rate: 1.1,  volume: 0.7 },
    _default:  { pitch: 1.0,  rate: 1.0,  volume: 0.8 },
  },

  init() {
    if (!this.synth) return;
    // Load voices (some browsers load async)
    this.voices = this.synth.getVoices();
    if (!this.voices.length) {
      this.synth.addEventListener('voiceschanged', () => {
        this.voices = this.synth.getVoices();
      });
    }
  },

  getVoice() {
    if (!this.voices || !this.voices.length) this.voices = this.synth.getVoices();
    // Prefer an English voice
    return this.voices.find(v => v.lang.startsWith('en') && v.localService) ||
           this.voices.find(v => v.lang.startsWith('en')) ||
           this.voices[0] || null;
  },

  speak(callsign, text) {
    if (!this.enabled || !this.synth) return;
    // Clean text of special chars
    const clean = text.replace(/[═▸✦●▲▼✈█~^│]/g, '').replace(/\s+/g, ' ').trim();
    if (!clean) return;

    const profile = this.profiles[callsign] || this.profiles._default;
    const utter = new SpeechSynthesisUtterance(clean);

    const voice = this.getVoice();
    if (voice) utter.voice = voice;

    utter.pitch = profile.pitch;
    utter.rate = profile.rate;
    utter.volume = profile.volume;

    // Queue management — don't let messages pile up
    utter.onend = () => {
      this.speaking = false;
      this.processQueue();
    };
    utter.onerror = () => {
      this.speaking = false;
      this.processQueue();
    };

    this.queue.push(utter);
    if (!this.speaking) this.processQueue();
  },

  processQueue() {
    if (this.queue.length === 0) return;
    // Skip to latest if queue is backed up (keep max 3)
    while (this.queue.length > 3) this.queue.shift();
    const utter = this.queue.shift();
    this.speaking = true;
    this.synth.speak(utter);
  },

  stop() {
    if (this.synth) this.synth.cancel();
    this.queue = [];
    this.speaking = false;
  },

  toggle() {
    this.enabled = !this.enabled;
    if (!this.enabled) this.stop();
    return this.enabled;
  }
};

tts.init();

// ─── GAME STATE ───────────────────────────────────────
const MAP_COLS = 8;
const MAP_ROWS = 8;
const COL_LABELS = 'ABCDEFGH';

const state = {
  running: false,
  paused: false,
  gameTime: 360, // 06:00 in minutes
  realTick: 0,
  tickIntervalId: null,
  tickSpeed: 1000, // 1 real second = 1 game minute
  eventQueue: [],
  eventsFired: new Set(),
  squads: {},
  enemies: [],
  pois: [],
  viperFound: false,
  viperFoundBy: null, // ALPHA or BRAVO - that squad guards until medevac
  viperGrid: null,
  viperSurvivors: 0,
  dustoffLaunched: false,
  dustoffGrid: null,
  dustoffArrivalTime: null,
  extractionDone: false,
  fireSupportsLeft: 2,
  airStrikesLeft: 1,
  choiceActive: false,
  missionEnd: false,
  totalCasualties: 0,
};

const commandHistory = [];
let historyIndex = -1;
let historyBuffer = '';

function initSquads() {
  state.squads = {
    ALPHA: {
      name: 'ALPHA',
      leader: 'Lt. Vasquez',
      personality: 'calm',
      col: 1, row: 1, // B2
      targetCol: null, targetRow: null,
      moving: false,
      moveTicksLeft: 0, // ticks until next grid step (terrain-dependent)
      pendingAmbush: false, // set up ambush on arrival
      morale: 5, ammo: 5, stamina: 5, strength: 12,
      status: 'idle', // idle, moving, engaged, pinned, ambush
      holdingFire: false,
    },
    BRAVO: {
      name: 'BRAVO',
      leader: 'Sgt. Kovacs',
      personality: 'nervous',
      col: 1, row: 5, // B6
      targetCol: null, targetRow: null,
      moving: false,
      moveTicksLeft: 0,
      pendingAmbush: false,
      morale: 5, ammo: 5, stamina: 5, strength: 10,
      status: 'idle',
      holdingFire: false,
    },
    DUSTOFF: {
      name: 'DUSTOFF',
      leader: 'CW2 Martinez',
      personality: 'professional',
      col: -1, row: -1,
      status: 'standby', // standby, inbound, onsite, extracting, rtb
      capacity: 6,
    }
  };
}

function initMap() {
  // Enemies (hidden initially)
  state.enemies = [
    { id: 'e1', col: 5, row: 3, strength: 8, revealed: false, alive: true },
    { id: 'e2', col: 6, row: 5, strength: 6, revealed: false, alive: true },
  ];
  // VIPER location
  state.viperGrid = { col: 4, row: 4 }; // E5
  state.viperSurvivors = 3;
  // POIs
  state.pois = [
    { col: 3, row: 2, symbol: '?', label: 'village', revealed: false },
    { col: 5, row: 4, symbol: '!', label: 'wreckage', revealed: false },
  ];
}

// ─── RENDERING ────────────────────────────────────────
function formatTime(mins) {
  const h = Math.floor(mins / 60);
  const m = mins % 60;
  return `${String(h).padStart(2,'0')}:${String(m).padStart(2,'0')}`;
}

function renderClock() {
  document.getElementById('clock').textContent = formatTime(state.gameTime);
}

function renderMap() {
  let lines = [];
  // Header
  let header = '   ';
  for (let c = 0; c < MAP_COLS; c++) header += ' ' + COL_LABELS[c] + ' ';
  lines.push(header);
  lines.push('   ' + '───'.repeat(MAP_COLS));

  for (let r = 0; r < MAP_ROWS; r++) {
    let row = ` ${r+1} │`;
    for (let c = 0; c < MAP_COLS; c++) {
      let ch = ' · ';
      // Terrain features
      if ((r === 2 && c >= 3 && c <= 5) || (r === 3 && c >= 4 && c <= 6)) ch = ' ~ '; // jungle
      if (r === 0 && c >= 5) ch = ' ^ '; // hills

      // POIs
      for (const poi of state.pois) {
        if (poi.col === c && poi.row === r && poi.revealed) ch = ` ${poi.symbol} `;
      }

      // VIPER
      if (state.viperFound && state.viperGrid.col === c && state.viperGrid.row === r) {
        ch = ' ✦ ';
      }

      // Enemies
      for (const e of state.enemies) {
        if (e.col === c && e.row === r && e.revealed && e.alive) ch = ' ● ';
      }

      // Dustoff
      if (state.squads.DUSTOFF.col === c && state.squads.DUSTOFF.row === r &&
          ['inbound','onsite','extracting'].includes(state.squads.DUSTOFF.status)) {
        ch = ' ✈ ';
      }

      // Friendly squads
      for (const key of ['ALPHA','BRAVO']) {
        const s = state.squads[key];
        if (s.col === c && s.row === r && s.strength > 0) {
          ch = key === 'ALPHA' ? ' ▲ ' : ' ▼ ';
        }
      }

      row += ch;
    }
    lines.push(row);
  }

  lines.push('');
  lines.push('  ▲ ALPHA  ▼ BRAVO  ● ENEMY  ✦ VIPER  ~ JUNGLE  ✈ DUSTOFF');

  const mapEl = document.getElementById('map');
  mapEl.textContent = lines.join('\n');
  let summary = `ALPHA at ${gridLabel(state.squads.ALPHA.col, state.squads.ALPHA.row)}, `;
  summary += `BRAVO at ${gridLabel(state.squads.BRAVO.col, state.squads.BRAVO.row)}`;
  if (state.viperFound) summary += `, VIPER at ${gridLabel(state.viperGrid.col, state.viperGrid.row)}`;
  for (const e of state.enemies) {
    if (e.alive && e.revealed) summary += `, Enemy at ${gridLabel(e.col, e.row)}`;
  }
  mapEl.setAttribute('aria-label', summary);
}

function renderStatus() {
  const container = document.getElementById('squad-status');
  let html = '';
  for (const key of ['ALPHA','BRAVO','DUSTOFF']) {
    const s = state.squads[key];
    if (key === 'DUSTOFF') {
      html += `<div class="squad-row"><span class="name">DUSTOFF</span><span class="squad-extra">${s.status.toUpperCase()}</span></div>`;
      continue;
    }
    html += `<div class="squad-row">`;
    html += `<span class="name">${key}</span>`;
    html += renderStat('MOR', s.morale, 5);
    html += renderStat('AMO', s.ammo, 5);
    html += renderStat('STA', s.stamina, 5);
    html += `<span class="squad-extra">${s.strength} soldiers │ ${s.status.toUpperCase()}</span>`;
    html += `</div>`;
  }
  html += `<div class="squad-row" style="margin-top:4px"><span class="squad-extra">FIRE SUPPORT: ${state.fireSupportsLeft} │ AIR STRIKE: ${state.airStrikesLeft}</span></div>`;
  container.innerHTML = html;
}

function renderStat(label, val, max) {
  let html = `<span class="stat" aria-label="${label} ${Math.round(val)} of ${max}">`;
  html += `<span class="stat-label" aria-hidden="true">${label}</span><span class="stat-bar" aria-hidden="true">`;
  for (let i = 0; i < max; i++) {
    const filled = i < Math.round(val);
    const critical = val <= 1 && filled;
    html += `<span class="stat-pip${filled?' filled':''}${critical?' critical':''}"></span>`;
  }
  html += `</span></span>`;
  return html;
}

function addRadio(callsign, text, type='normal') {
  const container = document.getElementById('radio-log-container');
  const div = document.createElement('div');
  div.className = `radio-msg ${type}`;
  const time = formatTime(state.gameTime);

  let csClass = 'callsign';
  if (callsign === 'COMMAND') csClass += ' command';
  if (callsign === 'SYSTEM') csClass += ' system';

  div.innerHTML = `<span class="timestamp">[${time}]</span> <span class="${csClass}">${callsign}:</span> <span class="body">${text}</span>`;
  container.appendChild(div);
  container.scrollTop = container.scrollHeight;

  // Only speak character dialog, not system messages or player commands
  // Character callsigns: ALPHA, BRAVO, DUSTOFF, ARTILLERY, FALCON, HQ
  const characterCallsigns = ['ALPHA', 'BRAVO', 'DUSTOFF', 'ARTILLERY', 'FALCON', 'HQ'];
  if (characterCallsigns.includes(callsign)) {
    tts.speak(callsign, `${callsign}: ${text}`);
  }
}

function addGarbled(callsign, text) {
  // Garble some characters
  let garbled = '';
  for (let i = 0; i < text.length; i++) {
    if (Math.random() < 0.25 && text[i] !== ' ') garbled += '█';
    else garbled += text[i];
  }
  addRadio(callsign, garbled, 'garbled');
}

function gridLabel(col, row) {
  return COL_LABELS[col] + (row + 1);
}

function parseGrid(str) {
  str = str.toUpperCase().trim();
  if (!/^[A-H][1-8]$/.test(str)) return null;
  const c = COL_LABELS.indexOf(str[0]);
  const r = parseInt(str[1]) - 1;
  return { col: c, row: r };
}

function dist(a, b) {
  return Math.abs(a.col - b.col) + Math.abs(a.row - b.row);
}

function isJungle(col, row) {
  return (row === 2 && col >= 3 && col <= 5) || (row === 3 && col >= 4 && col <= 6);
}

/** Returns list of unique grid labels where alive enemies are within range of pos (for reporting incoming fire) */
function getEnemyGridsNear(pos, range) {
  const labels = new Set();
  for (const e of state.enemies) {
    if (e.alive && dist(e, pos) <= range) labels.add(gridLabel(e.col, e.row));
  }
  return [...labels].sort();
}

// ─── PAUSE / PLAY ──────────────────────────────────────
function startTickInterval() {
  if (state.tickIntervalId) return;
  state.tickIntervalId = setInterval(() => {
    if (state.running && !state.missionEnd && !state.paused) tick();
  }, state.tickSpeed);
}

function stopTickInterval() {
  if (state.tickIntervalId) {
    clearInterval(state.tickIntervalId);
    state.tickIntervalId = null;
  }
}

function togglePause() {
  if (!state.running || state.missionEnd) return;
  state.paused = !state.paused;
  const btn = document.getElementById('pause-play');
  if (state.paused) {
    stopTickInterval();
    btn.textContent = 'PLAY';
    btn.setAttribute('aria-label', 'Resume game');
  } else {
    startTickInterval();
    btn.textContent = 'PAUSE';
    btn.setAttribute('aria-label', 'Pause game');
  }
}

// ─── COMMAND PARSER ───────────────────────────────────
function processCommand(raw) {
  const input = raw.trim().toUpperCase();
  if (!input) return;

  addRadio('COMMAND', raw.trim(), 'normal');

  if (state.choiceActive) {
    addRadio('SYSTEM', 'Respond to the current situation first.', 'event');
    return;
  }

  const parts = input.split(/\s+/);

  if (parts[0] === 'HELP') {
    addRadio('SYSTEM', '── Movement ──  [UNIT] MOVE [GRID] · [UNIT] HOLD · [UNIT] RETREAT', 'event');
    addRadio('SYSTEM', '── Combat ────  [UNIT] ENGAGE · [UNIT] AMBUSH [GRID] (move to grid, then set ambush; uses stamina)', 'event');
    addRadio('SYSTEM', '── Support ───  FIRE SUPPORT [GRID] · AIR STRIKE [GRID] · RESUPPLY [UNIT] · MEDEVAC', 'event');
    addRadio('SYSTEM', '── Info ──────  [UNIT] SITREP · STATUS · MAP · HELP', 'event');
    addRadio('SYSTEM', 'Units: ALPHA, BRAVO.  Grids: A1–H8.  Example: ALPHA MOVE E5', 'event');
    return;
  }

  if (parts[0] === 'STATUS') {
    for (const key of ['ALPHA','BRAVO']) {
      const s = state.squads[key];
      addRadio('SYSTEM', `${key} (${s.leader}) — Grid ${gridLabel(s.col,s.row)} — Morale:${s.morale} Ammo:${s.ammo} Stamina:${s.stamina} Strength:${s.strength} — ${s.status}`, 'event');
    }
    addRadio('SYSTEM', `DUSTOFF — ${state.squads.DUSTOFF.status.toUpperCase()}`, 'event');
    return;
  }

  if (parts[0] === 'MAP') {
    renderMap();
    addRadio('SYSTEM', 'Map refreshed.', 'event');
    return;
  }

  // FIRE SUPPORT [GRID]
  if (parts[0] === 'FIRE' && parts[1] === 'SUPPORT') {
    const grid = parseGrid(parts[2] || '');
    if (!grid) { addRadio('SYSTEM', 'Invalid grid. Usage: FIRE SUPPORT [GRID]', 'event');  return; }
    if (state.fireSupportsLeft <= 0) { addRadio('SYSTEM', 'No fire support missions remaining.', 'event');  return; }
    state.fireSupportsLeft--;
    addRadio('ARTILLERY', `Fire mission received. Rounds out on ${gridLabel(grid.col,grid.row)}. Splash in 2 mikes.`, 'normal');
    scheduleEvent(2, () => {
      addRadio('ARTILLERY', `Splash! Rounds complete on ${gridLabel(grid.col,grid.row)}.`, 'urgent');
      for (const e of state.enemies) {
        if (dist(e, grid) <= 1 && e.alive) {
          e.strength -= Math.floor(Math.random() * 5) + 3;
          if (e.strength <= 0) { e.alive = false; e.revealed = true; }
          else e.revealed = true;
        }
      }
      // Friendly fire check
      for (const key of ['ALPHA','BRAVO']) {
        const s = state.squads[key];
        if (dist(s, grid) <= 1) {
          const cas = Math.floor(Math.random() * 3) + 1;
          s.strength -= cas;
          s.strength = Math.max(0, s.strength);
          s.morale = Math.max(1, s.morale - 2);
          state.totalCasualties += cas;
          addRadio(key, `FRIENDLY FIRE! We're getting hit by our own arty! ${cas} men down!`, 'urgent');
          if (s.strength <= 0) { s.status = 'destroyed'; }
        }
      }
      checkGameOver();
      // VIPER check
      if (state.viperFound && dist(state.viperGrid, grid) <= 0) {
        state.viperSurvivors = Math.max(0, state.viperSurvivors - 2);
        addRadio('SYSTEM', 'WARNING: Fire mission impacted near VIPER position.', 'urgent');
      }
      renderMap();
    });
    return;
  }

  // AIR STRIKE [GRID]
  if (parts[0] === 'AIR' && parts[1] === 'STRIKE') {
    const grid = parseGrid(parts[2] || '');
    if (!grid) { addRadio('SYSTEM', 'Invalid grid. Usage: AIR STRIKE [GRID]', 'event');  return; }
    if (state.airStrikesLeft <= 0) { addRadio('SYSTEM', 'No air strikes remaining.', 'event');  return; }
    state.airStrikesLeft--;
    addRadio('FALCON', `Copy, rolling in on ${gridLabel(grid.col,grid.row)}. Bombs away in 3 mikes.`, 'normal');
    scheduleEvent(3, () => {
      addRadio('FALCON', `Good hit on ${gridLabel(grid.col,grid.row)}. Falcon is RTB.`, 'urgent');
      for (const e of state.enemies) {
        if (dist(e, grid) <= 1 && e.alive) {
          e.strength -= Math.floor(Math.random() * 6) + 4;
          if (e.strength <= 0) { e.alive = false; }
          e.revealed = true;
        }
      }
      for (const key of ['ALPHA','BRAVO']) {
        const s = state.squads[key];
        if (dist(s, grid) <= 1) {
          const cas = Math.floor(Math.random() * 4) + 1;
          s.strength -= cas;
          s.strength = Math.max(0, s.strength);
          s.morale = Math.max(1, s.morale - 2);
          state.totalCasualties += cas;
          addRadio(key, `We're danger close to that strike! ${cas} casualties!`, 'urgent');
          if (s.strength <= 0) { s.status = 'destroyed'; }
        }
      }
      checkGameOver();
      // VIPER check
      if (state.viperFound && dist(state.viperGrid, grid) <= 0) {
        state.viperSurvivors = Math.max(0, state.viperSurvivors - 2);
        addRadio('SYSTEM', 'WARNING: Air strike impacted near VIPER position.', 'urgent');
      }
      renderMap();
    });
    return;
  }

  // MEDEVAC [UNIT]
  if (parts[0] === 'MEDEVAC') {
    if (!state.viperFound) {
      addRadio('DUSTOFF', 'Need a grid for extraction. VIPER not yet located.', 'normal');
      return;
    }
    if (state.squads.DUSTOFF.status !== 'standby') {
      addRadio('DUSTOFF', 'DUSTOFF already deployed.', 'normal');
      return;
    }
    const targetGrid = state.viperGrid;
    state.squads.DUSTOFF.status = 'inbound';
    state.squads.DUSTOFF.col = targetGrid.col;
    state.squads.DUSTOFF.row = targetGrid.row;
    state.dustoffLaunched = true;
    state.dustoffArrivalTime = state.gameTime + 4;
    addRadio('DUSTOFF', `Copy, DUSTOFF is wheels up. Inbound to ${gridLabel(targetGrid.col, targetGrid.row)}. ETA 4 mikes.`, 'normal');
    scheduleEvent(4, () => {
      // Check if enemies nearby
      let hot = false;
      for (const e of state.enemies) {
        if (e.alive && dist(e, targetGrid) <= 2) hot = true;
      }
      if (hot) {
        state.squads.DUSTOFF.status = 'onsite';
        const fireGrids = getEnemyGridsNear(targetGrid, 2);
        const gridList = fireGrids.length ? fireGrids.join(', ') : 'unknown';
        addRadio('DUSTOFF', `LZ is HOT! We're taking fire from grid ${gridList}! Request suppression on those coordinates or we cannot land!`, 'urgent');
        // Give them a window
        scheduleEvent(3, () => {
          let stillHot = false;
          for (const e of state.enemies) {
            if (e.alive && dist(e, targetGrid) <= 2) stillHot = true;
          }
          if (stillHot) {
            const stillGrids = getEnemyGridsNear(targetGrid, 2);
            addRadio('DUSTOFF', `LZ still hot from grid ${stillGrids.join(', ') || 'unknown'}. We are aborting. DUSTOFF RTB.`, 'urgent');
            state.squads.DUSTOFF.status = 'standby';
            state.squads.DUSTOFF.col = -1;
            state.squads.DUSTOFF.row = -1;
            state.dustoffLaunched = false;
          } else {
            performExtraction();
          }
        });
      } else {
        state.squads.DUSTOFF.status = 'onsite';
        addRadio('DUSTOFF', `LZ is cold. Touching down now.`, 'normal');
        scheduleEvent(2, () => performExtraction());
      }
      renderMap();
    });
    return;
  }

  // RESUPPLY [UNIT]
  if (parts[0] === 'RESUPPLY') {
    const squad = state.squads[parts[1]];
    if (!squad || parts[1] === 'DUSTOFF') { addRadio('SYSTEM', 'Invalid unit.', 'event');  return; }
    addRadio('SYSTEM', `Resupply inbound to ${parts[1]}. ETA 3 mikes.`, 'event');
    scheduleEvent(3, () => {
      squad.ammo = Math.min(5, squad.ammo + 3);
      squad.stamina = Math.min(5, squad.stamina + 1);
      addRadio(parts[1], 'Resupply received. Ammo restocked.', 'normal');
    });
    return;
  }

  // Squad commands
  const squadName = parts[0];
  const squad = state.squads[squadName];
  if (!squad || squadName === 'DUSTOFF') {
    addRadio('SYSTEM', `Unknown callsign "${squadName}". Available: ALPHA, BRAVO`, 'event');
    return;
  }
  if (squad.strength <= 0) {
    addRadio('SYSTEM', `${squadName} is combat ineffective.`, 'event');
    return;
  }

  const cmd = parts[1];

  if (cmd === 'MOVE') {
    if (squad.status === 'engaged') { addRadio('SYSTEM', `${squadName} cannot move while engaged in combat.`, 'event');  return; }
    if (state.viperFoundBy === squadName) { addRadio(squadName, "We're with the survivors — we can't leave until DUSTOFF extracts them.", 'normal');  return; }
    const grid = parseGrid(parts[2] || '');
    if (!grid) { addRadio('SYSTEM', 'Invalid grid. Usage: [UNIT] MOVE [GRID]', 'event');  return; }
    squad.targetCol = grid.col;
    squad.targetRow = grid.row;
    squad.moving = true;
    squad.status = 'moving';
    squad.moveTicksLeft = 2; // first step after 2 minutes (terrain may add more per cell)
    const moveDist = dist(squad, grid);
    const eta = Math.max(2, moveDist * 2); // ~2 min per cell
    const response = squad.personality === 'nervous'
      ? `Copy that... moving to ${gridLabel(grid.col,grid.row)}. Hope it's quiet out there.`
      : `Roger, moving to ${gridLabel(grid.col,grid.row)}. ETA ${eta} mikes.`;
    addRadio(squadName, response, 'normal');
    return;
  }

  if (cmd === 'HOLD') {
    squad.moving = false;
    squad.targetCol = null;
    squad.targetRow = null;
    squad.status = 'idle';
    const response = squad.personality === 'nervous'
      ? `Holding position at ${gridLabel(squad.col,squad.row)}. Keeping our heads down.`
      : `Copy, holding at ${gridLabel(squad.col,squad.row)}.`;
    addRadio(squadName, response, 'normal');
    return;
  }

  if (cmd === 'RETREAT') {
    if (state.viperFoundBy === squadName) { addRadio(squadName, "We're with the survivors — we can't leave until DUSTOFF extracts them.", 'normal');  return; }
    if (squad.col === 0) {
      addRadio('SYSTEM', `${squadName} cannot retreat further.`, 'event');
      return;
    }
    squad.moving = false;
    squad.status = 'idle';
    squad.col--;
    squad.morale = Math.max(1, squad.morale - 1);
    addRadio(squadName, `Falling back to ${gridLabel(squad.col,squad.row)}.`, 'normal');
    renderMap();
    return;
  }

  if (cmd === 'ENGAGE') {
    let nearest = null;
    let minD = 999;
    for (const e of state.enemies) {
      if (e.alive && e.revealed) {
        const d = dist(squad, e);
        if (d < minD) { minD = d; nearest = e; }
      }
    }
    if (!nearest || minD > 3) {
      addRadio(squadName, 'No confirmed enemy contacts in range.', 'normal');
      return;
    }
    squad.status = 'engaged';
    squad.ammo = Math.max(0, squad.ammo - 1);
    squad.stamina = Math.max(0, squad.stamina - 1);
    addRadio(squadName, `Engaging enemy at ${gridLabel(nearest.col,nearest.row)}!`, 'urgent');
    // Resolve combat
    scheduleEvent(1, () => resolveCombat(squad, nearest));
    return;
  }

  if (cmd === 'AMBUSH') {
    if (state.viperFoundBy === squadName) {
      let underFire = false;
      for (const e of state.enemies) {
        if (e.alive && dist(squad, e) <= 2) { underFire = true; break; }
      }
      if (underFire) {
        addRadio(squadName, "We're under fire defending the survivors — can't set up an ambush. Need that LZ cleared for DUSTOFF.", 'normal');
        return;
      }
    }
    const grid = parseGrid(parts[2] || '');
    if (grid && (grid.col !== squad.col || grid.row !== squad.row)) {
      if (state.viperFoundBy === squadName) { addRadio(squadName, "We're with the survivors — we can't leave to set up an ambush elsewhere.", 'normal');  return; }
      squad.targetCol = grid.col;
      squad.targetRow = grid.row;
      squad.moving = true;
      squad.status = 'moving';
      squad.pendingAmbush = true;
      squad.moveTicksLeft = 2;
      addRadio(squadName, `Moving to ${gridLabel(grid.col,grid.row)} to set up ambush. We'll use stamina to dig in when we get there.`, 'normal');
      return;
    }
    squad.status = 'ambush';
    squad.moving = false;
    squad.pendingAmbush = false;
    squad.stamina = Math.max(0, squad.stamina - 1);
    addRadio(squadName, `Setting up ambush at ${gridLabel(squad.col,squad.row)}. Stamina spent — we're ready.`, 'normal');
    return;
  }

  if (cmd === 'SITREP') {
    let report = `${squad.leader} here. Position ${gridLabel(squad.col,squad.row)}. `;
    report += `${squad.strength} effectives. `;
    if (squad.ammo <= 1) report += 'Running LOW on ammo. ';
    if (squad.stamina <= 1) report += 'Men are exhausted. ';
    if (squad.morale <= 2) report += 'Morale is shaky. ';
    // Check nearby enemies
    let nearbyEnemy = false;
    for (const e of state.enemies) {
      if (e.alive && dist(squad, e) <= 2) nearbyEnemy = true;
    }
    if (nearbyEnemy) report += 'We can hear movement nearby.';
    else report += 'Area seems quiet for now.';

    if (squad.morale <= 2) {
      addGarbled(squadName, report);
    } else {
      addRadio(squadName, report, 'normal');
    }
    return;
  }

  if (cmd === 'REGROUP') {
    if (state.viperFoundBy === squadName) { addRadio(squadName, "We're with the survivors — we can't leave until DUSTOFF extracts them.", 'normal');  return; }
    if (parts[2] === squadName) { addRadio('SYSTEM', `${squadName} cannot regroup with itself.`, 'event');  return; }
    const other = state.squads[parts[2]];
    if (!other || parts[2] === 'DUSTOFF') { addRadio('SYSTEM', 'Invalid regroup target.', 'event');  return; }
    squad.targetCol = other.col;
    squad.targetRow = other.row;
    squad.moving = true;
    squad.status = 'moving';
    addRadio(squadName, `Moving to regroup with ${parts[2]} at ${gridLabel(other.col,other.row)}.`, 'normal');
    return;
  }

  addRadio('SYSTEM', `Unknown command "${cmd}". Type HELP for commands.`, 'event');
}

// ─── COMBAT ───────────────────────────────────────────
function resolveCombat(squad, enemy) {
  if (!enemy.alive || squad.strength <= 0) return;

  const squadPower = squad.strength * (squad.morale / 5) * (squad.ammo > 0 ? 1 : 0.2);
  const enemyPower = enemy.strength * 0.8;
  const roll = Math.random() * (squadPower + enemyPower);

  if (roll < squadPower) {
    // We win this exchange
    const eDamage = Math.floor(Math.random() * 4) + 2;
    enemy.strength -= eDamage;
    const sCas = Math.floor(Math.random() * 2);
    squad.strength -= sCas;
    squad.strength = Math.max(0, squad.strength);
    state.totalCasualties += sCas;

    if (enemy.strength <= 0) {
      enemy.alive = false;
      addRadio(squad.name, `Enemy neutralized! ${sCas > 0 ? sCas + ' casualties on our side.' : 'No casualties.'}`, 'urgent');
      squad.status = 'idle';
      squad.morale = Math.min(5, squad.morale + 1);
    } else {
      addRadio(squad.name, `We're hitting them hard. They're pulling back but still fighting. ${sCas > 0 ? 'We took ' + sCas + ' hit' + (sCas>1?'s':'') + '.' : ''}`, 'urgent');
      // Continue
      scheduleEvent(1, () => resolveCombat(squad, enemy));
    }
  } else {
    // We take hits
    const sCas = Math.floor(Math.random() * 3) + 1;
    squad.strength -= sCas;
    squad.strength = Math.max(0, squad.strength);
    squad.morale = Math.max(0, squad.morale - 1);
    state.totalCasualties += sCas;
    const enemyGrid = gridLabel(enemy.col, enemy.row);

    if (squad.strength <= 0) {
      addRadio(squad.name, `We're overrun! Taking fire from grid ${enemyGrid}! ${squad.leader}... *static*`, 'garbled');
      squad.status = 'destroyed';
      checkGameOver();
    } else if (squad.morale <= 1) {
      addRadio(squad.name, `${sCas} down! Incoming from grid ${enemyGrid}! We can't hold this! Breaking contact!`, 'urgent');
      squad.status = 'idle';
      if (squad.col > 0) squad.col--;
    } else {
      const nervous = squad.personality === 'nervous';
      addRadio(squad.name, `${sCas} casualties! Taking fire from grid ${enemyGrid}! ${nervous ? 'Oh God... they\'re everywhere!' : 'Still in the fight!'}`, 'urgent');
      squad.ammo = Math.max(0, squad.ammo - 1);
      scheduleEvent(1, () => resolveCombat(squad, enemy));
    }
  }
  renderMap();
  renderStatus();
}

function performExtraction() {
  if (state.viperSurvivors <= 0) {
    addRadio('DUSTOFF', 'No survivors to extract. DUSTOFF is RTB.', 'urgent');
    state.squads.DUSTOFF.status = 'standby';
    state.squads.DUSTOFF.col = -1;
    state.squads.DUSTOFF.row = -1;
    renderMap();
    return;
  }
  state.squads.DUSTOFF.status = 'extracting';
  addRadio('DUSTOFF', `Loading ${state.viperSurvivors} VIPER survivors now...`, 'normal');
  scheduleEvent(2, () => {
    state.squads.DUSTOFF.status = 'rtb';
    state.extractionDone = true;
    state.viperFoundBy = null; // guard squad is no longer pinned
    addRadio('DUSTOFF', `We've got them. ${state.viperSurvivors} survivors aboard. DUSTOFF is RTB.`, 'urgent');
    state.squads.DUSTOFF.col = -1;
    state.squads.DUSTOFF.row = -1;
    scheduleEvent(3, () => {
      addRadio('DUSTOFF', 'DUSTOFF is back at base. Survivors are in triage.', 'normal');
      state.squads.DUSTOFF.status = 'standby';
      checkWin();
    });
    renderMap();
  });
}

// ─── EVENT SYSTEM ─────────────────────────────────────
function scheduleEvent(delayMins, fn) {
  state.eventQueue.push({ time: state.gameTime + delayMins, fn });
}

function processEvents() {
  const toFire = state.eventQueue.filter(e => state.gameTime >= e.time);
  state.eventQueue = state.eventQueue.filter(e => state.gameTime < e.time);
  for (const e of toFire) e.fn();
}

function setupMissionEvents() {
  // Early radio chatter
  scheduleEvent(1, () => {
    addRadio('ALPHA', `${state.squads.ALPHA.leader} here. Alpha is ready to move. Awaiting orders.`, 'normal');
  });
  scheduleEvent(2, () => {
    addRadio('BRAVO', `Bravo in position. ${state.squads.BRAVO.leader} standing by. It's quiet... too quiet.`, 'normal');
  });
  // Gentle reminder for new players
  scheduleEvent(4, () => {
    if (!state.squads.ALPHA.moving && !state.squads.BRAVO.moving) {
      addRadio('HQ', 'Papa Bear, both squads are stationary. You can send them toward VIPER\'s last position. Try: ALPHA MOVE D4', 'event');
    }
  });

  // Discovery events based on position checks (handled in tick)
  // At 06:08, base intel
  scheduleEvent(8, () => {
    if (!state.eventsFired.has('intel1')) {
      state.eventsFired.add('intel1');
      addRadio('HQ', 'Papa Bear, we have SIGINT suggesting enemy patrol activity near grids E-F, rows 3-6. Advise caution.', 'event');
    }
  });

  // At 06:15, pressure
  scheduleEvent(15, () => {
    if (!state.viperFound) {
      addRadio('HQ', 'Papa Bear, VIPER team has been missing for 18 hours. Time is critical. What is your status?', 'urgent');
    }
  });

  // Time limit warning
  scheduleEvent(17, () => {
    addRadio('HQ', 'Papa Bear, you have approximately 3 minutes before we lose daylight. Wrap it up.', 'urgent');
  });

  // End mission at 20 min
  scheduleEvent(20, () => {
    endMission();
  });
}

// ─── PROXIMITY EVENTS ─────────────────────────────────
function checkProximityEvents() {
  for (const key of ['ALPHA','BRAVO']) {
    const s = state.squads[key];
    if (s.strength <= 0) continue;

    // Village discovery
    const village = state.pois.find(p => p.label === 'village');
    if (village && !village.revealed && dist(s, village) <= 1) {
      village.revealed = true;
      showChoice(
        `${key}: We've found a village at ${gridLabel(village.col,village.row)}. Locals look scared. Do we question them about VIPER?`,
        [
          { label: 'QUESTION THEM', fn: () => {
            addRadio(key, 'Talking to village elder now...', 'normal');
            scheduleEvent(2, () => {
              addRadio(key, `Elder says they saw American soldiers being dragged east toward ${gridLabel(state.viperGrid.col, state.viperGrid.row)} two days ago. Looked bad.`, 'normal');
              state.pois.find(p => p.label === 'wreckage').revealed = true;
              renderMap();
            });
          }},
          { label: 'PASS THROUGH', fn: () => {
            addRadio(key, 'Roger, moving past the village.', 'normal');
          }},
        ]
      );
    }

    // VIPER discovery — survivors stay with this unit; unit guards until medevac
    if (!state.viperFound && dist(s, state.viperGrid) <= 1) {
      state.viperFound = true;
      state.viperFoundBy = key;
      s.moving = false;
      s.targetCol = null;
      s.targetRow = null;
      // Keep current status (e.g. ambush) so they can still use it while guarding
      addRadio(key, `CONTACT! We found them! VIPER team is here at ${gridLabel(state.viperGrid.col,state.viperGrid.row)}! ${state.viperSurvivors} survivors, badly wounded. We're staying with them until DUSTOFF. They need medevac now!`, 'urgent');
      // Enemy reacts
      scheduleEvent(2, () => {
        state.enemies[0].revealed = true;
        addRadio(key, `Enemy contact! We've got hostiles moving in from ${gridLabel(state.enemies[0].col,state.enemies[0].row)}!`, 'urgent');
        if (s.status === 'ambush') {
          addRadio(key, `They walked right into our ambush! Opening fire!`, 'urgent');
          state.enemies[0].strength -= 3;
          s.ammo = Math.max(0, s.ammo - 1);
        }
        renderMap();
      });
      renderMap();
    }

    // Enemy proximity (not yet revealed)
    for (const e of state.enemies) {
      if (e.alive && !e.revealed && dist(s, e) <= 1 && s.status !== 'engaged') {
        e.revealed = true;
        if (s.status === 'ambush') {
          addRadio(key, `Enemy patrol at ${gridLabel(e.col,e.row)}! They don't see us. We have the drop on them.`, 'urgent');
        } else {
          s.status = 'engaged';
          addRadio(key, `CONTACT! Enemy at ${gridLabel(e.col,e.row)}! Taking fire!`, 'urgent');
          scheduleEvent(1, () => resolveCombat(s, e));
        }
        renderMap();
      }
    }

    // Wreckage POI
    const wreckage = state.pois.find(p => p.label === 'wreckage');
    if (wreckage && wreckage.revealed && !state.eventsFired.has('wreckage_'+key) && dist(s, wreckage) <= 0) {
      state.eventsFired.add('wreckage_'+key);
      addRadio(key, `Found some gear here... blood trails leading east. VIPER was here. They were ambushed.`, 'normal');
    }
  }
}

// ─── CHOICES ──────────────────────────────────────────
function showChoice(prompt, options) {
  state.choiceActive = true;
  const overlay = document.getElementById('choice-overlay');
  const promptEl = document.getElementById('choice-prompt');
  const optionsEl = document.getElementById('choice-options');
  overlay.classList.remove('hidden');
  promptEl.textContent = prompt;
  optionsEl.innerHTML = '';
  for (const opt of options) {
    const btn = document.createElement('button');
    btn.textContent = opt.label;
    btn.onclick = () => {
      overlay.classList.add('hidden');
      state.choiceActive = false;
      opt.fn();
      document.getElementById('cmd').focus();
    };
    optionsEl.appendChild(btn);
  }
  optionsEl.querySelector('button').focus();
}

// ─── GAME LOOP ────────────────────────────────────────
function tick() {
  if (!state.running || state.missionEnd) return;

  state.gameTime++;
  state.realTick++;

  // Move squads (terrain: 2 min per cell open, 3 min in jungle)
  for (const key of ['ALPHA','BRAVO']) {
    const s = state.squads[key];
    if (s.moving && s.targetCol !== null && s.strength > 0) {
      if (s.moveTicksLeft > 0) {
        s.moveTicksLeft--;
      } else {
        // Decide next cell; next step will wait 2 (open) or 3 (jungle) minutes
        const nextCol = s.col < s.targetCol ? s.col + 1 : s.col > s.targetCol ? s.col - 1 : s.col;
        const nextRow = s.row < s.targetRow ? s.row + 1 : s.row > s.targetRow ? s.row - 1 : s.row;
        const inJungle = isJungle(nextCol, nextRow);
        s.moveTicksLeft = inJungle ? 3 : 2; // minutes until next cell

        s.col = nextCol;
        s.row = nextRow;
        s.stamina = Math.max(0, s.stamina - 0.2);
        if (inJungle) {
          s.stamina = Math.max(0, s.stamina - 0.3);
          if (!state.eventsFired.has('jungle_' + key)) {
            state.eventsFired.add('jungle_' + key);
            addRadio(key, 'Pushing through dense jungle. Slow going.', 'normal');
          }
        }

        if (s.col === s.targetCol && s.row === s.targetRow) {
          s.moving = false;
          s.targetCol = null;
          s.targetRow = null;
          s.moveTicksLeft = 0;
          if (s.pendingAmbush) {
            s.pendingAmbush = false;
            s.status = 'ambush';
            s.stamina = Math.max(0, s.stamina - 1.5);
            addRadio(key, `In position at ${gridLabel(s.col,s.row)}. Ambush set. We're ready.`, 'normal');
          } else {
            s.status = 'idle';
            addRadio(key, `In position at ${gridLabel(s.col,s.row)}.`, 'normal');
          }
        }
      }
    }

    // Stamina floor
    if (s.stamina <= 0) s.stamina = 0;
    if (s.stamina <= 1 && s.morale > 1 && !state.eventsFired.has('tired_'+key+'_'+state.realTick)) {
      if (state.realTick % 8 === 0) {
        state.eventsFired.add('tired_'+key+'_'+state.realTick);
        addRadio(key, 'Men are exhausted, Commander. We need rest.', 'normal');
        s.morale = Math.max(1, s.morale - 0.5);
      }
    }
  }

  processEvents();
  checkProximityEvents();

  renderClock();
  renderMap();
  renderStatus();
}

// ─── SCORING ──────────────────────────────────────────
function calculateScore() {
  let score = 0;
  score += state.viperSurvivors * 1000;
  const elapsed = state.gameTime - 360;
  score += Math.max(0, Math.round((20 - elapsed) / 10 * 2000));
  score -= state.totalCasualties * 200;
  score -= (2 - state.fireSupportsLeft) * 150;
  score -= (1 - state.airStrikesLeft) * 150;
  if (state.squads.ALPHA.strength > 0) score += 500;
  if (state.squads.BRAVO.strength > 0) score += 500;
  score = Math.max(0, score);

  let grade;
  if (score >= 5000) grade = 'S';
  else if (score >= 4000) grade = 'A';
  else if (score >= 3000) grade = 'B';
  else if (score >= 2000) grade = 'C';
  else if (score >= 1000) grade = 'D';
  else grade = 'F';

  return { score, grade };
}

// ─── WIN/LOSE ─────────────────────────────────────────
function checkGameOver() {
  const a = state.squads.ALPHA;
  const b = state.squads.BRAVO;
  if (a.strength <= 0 && b.strength <= 0) {
    endMission();
  }
}

function checkWin() {
  if (state.extractionDone && state.viperSurvivors >= 2) {
    state.missionEnd = true;
    state.running = false;
    document.getElementById('cmd').disabled = true;
    tts.stop();
    setTimeout(() => {
      const overlay = document.getElementById('gameover-overlay');
      overlay.classList.remove('hidden');
      document.getElementById('gameover-title').textContent = 'MISSION COMPLETE';
      document.getElementById('gameover-text').textContent = `${state.viperSurvivors} VIPER survivors extracted successfully.`;
      const { score, grade } = calculateScore();
      document.getElementById('gameover-stats').textContent = `Score: ${score} (${grade}) │ Casualties: ${state.totalCasualties} │ ALPHA: ${state.squads.ALPHA.strength} │ BRAVO: ${state.squads.BRAVO.strength}`;
    }, 2000);
  }
}

function endMission() {
  if (state.missionEnd) return;
  state.missionEnd = true;
  state.running = false;
  stopTickInterval();
  tts.stop();

  const overlay = document.getElementById('gameover-overlay');
  overlay.classList.remove('hidden');

  if (state.extractionDone && state.viperSurvivors >= 2) {
    document.getElementById('gameover-title').textContent = 'MISSION COMPLETE';
    document.getElementById('gameover-text').textContent = `${state.viperSurvivors} VIPER survivors extracted. Well done, Commander.`;
  } else if (state.squads.ALPHA.strength <= 0 && state.squads.BRAVO.strength <= 0) {
    document.getElementById('gameover-title').textContent = 'MISSION FAILED';
    document.getElementById('gameover-text').textContent = 'All units lost. There was no one left to send.';
  } else if (!state.viperFound) {
    document.getElementById('gameover-title').textContent = 'MISSION FAILED';
    document.getElementById('gameover-text').textContent = 'VIPER team was never located. They are presumed KIA.';
  } else {
    document.getElementById('gameover-title').textContent = 'MISSION FAILED';
    document.getElementById('gameover-text').textContent = 'VIPER team was found but extraction was not completed in time.';
  }
  const { score, grade } = calculateScore();
  document.getElementById('gameover-stats').textContent = `Score: ${score} (${grade}) │ Casualties: ${state.totalCasualties} │ ALPHA: ${state.squads.ALPHA.strength} │ BRAVO: ${state.squads.BRAVO.strength}`;
  document.getElementById('cmd').disabled = true;
}

// ─── INIT ─────────────────────────────────────────────
function startGame() {
  document.getElementById('briefing-overlay').classList.add('hidden');
  document.getElementById('cmd').disabled = false;
  document.getElementById('cmd').focus();

  initSquads();
  initMap();
  setupMissionEvents();

  state.running = true;
  state.paused = true; // clock runs when player clicks PLAY
  const ppBtn = document.getElementById('pause-play');
  ppBtn.textContent = 'PLAY';
  ppBtn.setAttribute('aria-label', 'Resume game');

  addRadio('SYSTEM', '═══ OPERATION BRIGHT LIGHT ═══', 'event');
  addRadio('SYSTEM', 'Radio channel open. You are PAPA BEAR. Issue commands to your units.', 'event');
  addRadio('SYSTEM', 'Type HELP for commands. Click PLAY to run the clock (1 sec = 1 min).', 'event');

  renderClock();
  renderMap();
  renderStatus();
}

// Command input (with history + autocomplete)
document.getElementById('cmd').addEventListener('keydown', (e) => {
  if (e.key === 'Enter') {
    const input = e.target.value;
    e.target.value = '';
    if (input.trim()) {
      commandHistory.push(input.trim());
      if (commandHistory.length > 20) commandHistory.shift();
      historyIndex = -1;
      historyBuffer = '';
      processCommand(input);
    }
  } else if (e.key === 'ArrowUp') {
    e.preventDefault();
    if (commandHistory.length === 0) return;
    if (historyIndex === -1) {
      historyBuffer = e.target.value;
      historyIndex = commandHistory.length - 1;
    } else if (historyIndex > 0) {
      historyIndex--;
    }
    e.target.value = commandHistory[historyIndex];
  } else if (e.key === 'ArrowDown') {
    e.preventDefault();
    if (historyIndex === -1) return;
    if (historyIndex < commandHistory.length - 1) {
      historyIndex++;
      e.target.value = commandHistory[historyIndex];
    } else {
      historyIndex = -1;
      e.target.value = historyBuffer;
    }
  } else if (e.key === 'Tab') {
    e.preventDefault();
    const val = e.target.value;
    const parts = val.trimEnd().split(/\s+/);
    const current = parts[parts.length - 1].toUpperCase();

    let completions = [];
    if (parts.length <= 1) {
      completions = ['ALPHA', 'BRAVO', 'HELP', 'STATUS', 'MAP', 'FIRE', 'AIR', 'MEDEVAC', 'RESUPPLY'];
    } else if (parts.length === 2 && ['ALPHA','BRAVO'].includes(parts[0].toUpperCase())) {
      completions = ['MOVE', 'HOLD', 'RETREAT', 'ENGAGE', 'AMBUSH', 'SITREP', 'REGROUP'];
    } else if (parts.length === 2 && parts[0].toUpperCase() === 'FIRE') {
      completions = ['SUPPORT'];
    } else if (parts.length === 2 && parts[0].toUpperCase() === 'AIR') {
      completions = ['STRIKE'];
    }

    const matches = completions.filter(c => c.startsWith(current) && c !== current);
    if (matches.length === 1) {
      parts[parts.length - 1] = matches[0];
      e.target.value = parts.join(' ') + ' ';
    } else if (matches.length > 1) {
      let prefix = matches[0];
      for (const m of matches) {
        while (!m.startsWith(prefix)) prefix = prefix.slice(0, -1);
      }
      if (prefix.length > current.length) {
        parts[parts.length - 1] = prefix;
        e.target.value = parts.join(' ');
      }
    }
  }
});

// TTS toggle
function toggleTTS() {
  const on = tts.toggle();
  const el = document.getElementById('tts-toggle');
  el.textContent = 'VOICE: ' + (on ? 'ON' : 'OFF');
  el.style.color = on ? 'var(--dim)' : 'var(--border)';
  el.setAttribute('aria-pressed', String(on));
}

// Focus input on click anywhere
document.addEventListener('click', (e) => {
  if (!document.getElementById('cmd').disabled && !('ontouchstart' in window)) {
    document.getElementById('cmd').focus();
  }
});

// Expose game internals for testing
window.__game = {
  state,
  tts,
  processCommand,
  startGame,
  startTickInterval,
  stopTickInterval,
  togglePause,
  initSquads,
  initMap,
  setupMissionEvents,
  tick,
  resolveCombat,
  performExtraction,
  endMission,
  checkGameOver,
  checkWin,
  addRadio,
  addGarbled,
  renderMap,
  renderStatus,
  renderClock,
  gridLabel,
  parseGrid,
  dist,
  showChoice,
  scheduleEvent,
  processEvents,
  checkProximityEvents,
  formatTime,
  toggleTTS,
  calculateScore,
  commandHistory,
};
</script>
</body>
</html>
